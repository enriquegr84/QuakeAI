// Geometric Tools, LLC
// Copyright (c) 1998-2014
// Distributed under the Boost Software License, Version 1.0.
// http://www.boost.org/LICENSE_1_0.txt
// http://www.geometrictools.com/License/Boost/LICENSE_1_0.txt
//
// File Version: 5.0.2 (2011/08/13)

#ifndef OS_H
#define OS_H

#include "Core/CoreStd.h"

class ByteSwap
{
public:

	static unsigned int Byteswap(unsigned int num);
	static signed int Byteswap(signed int num);
	//static float Byteswap(float num);
	// prevent accidental swapping of chars
	static char  Byteswap(char  num);
};


// mixed linear congruential generator (MLCG)
// numbers chosen according to L'Ecuyer, Commun. ACM 31 (1988) 742
// period is somewhere around m-1
class Randomizer
{
public:

	//! resets the randomizer
	static void Reset(signed int value=0x0f0f0f0f);

	//! generates a pseudo random number in the range 0..RandMax()
	static signed int Rand();

	//! generates a pseudo random number in the range 0..1
	static float FRand();

	//! get maxmimum number generated by Rand()
	static signed int RandMax();

private:

	static signed int seed;
	static const signed int m = 2147483399;	// a non-Mersenne prime
	static const signed int a = 40692;			// another spectral success story
	static const signed int q = m/a;
	static const signed int r = m%a;			// again less than q
	static const signed int rMax = m-1;
};


// Note: this class is not polymorphic so that its high level of
// optimizability may be preserved in the common use case
class PseudoRandom
{
public:
    const static unsigned int RANDOM_RANGE = 32767;

    inline PseudoRandom(int seed = 0) : mNext(seed)
    {
    }

    inline void Seed(int seed)
    {
        mNext = seed;
    }

    inline int Next()
    {
        mNext = mNext * 1103515245 + 12345;
        return (unsigned)(mNext / 65536) % (RANDOM_RANGE + 1);
    }

    inline int Range(int min, int max)
    {
        if (max < min)
            throw RNGException("Invalid range (max < min)");
        /*
        Here, we ensure the range is not too large relative to RANDOM_MAX,
        as otherwise the effects of bias would become noticable.  Unlike
        PcgRandom, we cannot modify this RNG's range as it would change the
        output of this RNG for reverse compatibility.
        */
        if ((unsigned int)(max - min) > (RANDOM_RANGE + 1) / 10)
            throw RNGException("Range too large");

        return (Next() % (max - min + 1)) + min;
    }

private:
    int mNext;
};

class PcgRandom
{
public:
    const static int RANDOM_MIN = -0x7fffffff - 1;
    const static int RANDOM_MAX = 0x7fffffff;
    const static unsigned int RANDOM_RANGE = 0xffffffff;

    PcgRandom(uint64_t state = 0x853c49e6748fea9bULL, uint64_t seq = 0xda3e39cb94b95bdbULL);
    void Seed(uint64_t state, uint64_t seq = 0xda3e39cb94b95bdbULL);
    unsigned int Next();
    unsigned int Range(unsigned int bound);
    int Range(int min, int max);
    void Bytes(void *out, size_t len);
    int RandNormalDist(int min, int max, int num_trials = 6);

private:
    uint64_t mState;
    uint64_t mInc;
};


class IntervalLimiter
{
public:
    IntervalLimiter() = default;

    /*
        deltaTime: time from last call to this method
        wantedInterval: interval wanted
        return value:
            true: action should be skipped
            false: action should be done
    */
    bool Step(float deltaTime, float wantedInterval)
    {
        mAccumulator += deltaTime;
        if (mAccumulator < wantedInterval)
            return false;
        mAccumulator -= wantedInterval;
        return true;
    }

private:
    float mAccumulator = 0.0f;
};


/*
    TimeTaker
*/

enum TimePrecision
{
    PRECISION_SECONDS,
    PRECISION_MILLI,
    PRECISION_MICRO,
    PRECISION_NANO
};

class TimeTaker
{
public:
    TimeTaker(const std::string& name, uint64_t* result = nullptr,
        TimePrecision prec = PRECISION_MILLI);

    ~TimeTaker()
    {
        Stop();
    }

    uint64_t Stop(bool quiet = false);

    uint64_t GetTimeElapsed();

protected:

    uint64_t GetTime(TimePrecision prec);

private:
    std::string mName;
    uint64_t mTime;
    bool mRunning = true;
    TimePrecision mPrecision;
    uint64_t* mResult = nullptr;
};

/*
	The timer class wraps calls to the API high-resolution performance counter, 
	a timer that increments a value at a frequency expressed in counts per second.
	The system timer is critical for synchronize game logic with the views. Almost
	every game subsystem will care about time. Some systems have multiple methods
	of getting access to the system timer, each with different levels of resolution
	or precision.
*/
class Timer
{
public:

	enum EWeekday
	{
		EWD_SUNDAY=0,
		EWD_MONDAY,
		EWD_TUESDAY,
		EWD_WEDNESDAY,
		EWD_THURSDAY,
		EWD_FRIDAY,
		EWD_SATURDAY
	};

	struct RealTimeDate
	{
		// Hour of the day, from 0 to 23
		unsigned int Hour;
		// Minute of the hour, from 0 to 59
		unsigned int Minute;
		// Second of the minute, due to extra seconds from 0 to 61
		unsigned int Second;
		// Year of the gregorian calender
		signed int Year;
		// Month of the year, from 1 to 12
		unsigned int Month;
		// Day of the month, from 1 to 31
		unsigned int Day;
		// Weekday for the current day
		EWeekday Weekday;
		// Day of the year, from 1 to 366
		unsigned int Yearday;
		// Whether daylight saving is on
		bool IsDST;
	};

	//! Returns the number of seconds since 1.1.1970.
	static long long GetTimeSinceEpoch();

	//! returns the current time in milliseconds
	static unsigned int GetTime();

	//! get current time and date in calendar form
	static Timer::RealTimeDate GetRealTimeAndDate();

	//! initializes the real timer
	static void InitTimer(bool usePerformanceTimer=true);

	//! sets the current virtual (game) time
	static void SetTime(unsigned int time);

	//! stops the virtual (game) timer
	static void StopTimer();

	//! starts the game timer
	static void StartTimer();

	//! sets the speed of the virtual timer
	static void SetSpeed(float speed);

	//! gets the speed of the virtual timer
	static float GetSpeed();

	//! returns if the timer currently is stopped
	static bool IsStopped();

	//! makes the virtual timer update the time value based on the real time
	static void Tick();

	//! returns the current real time in milliseconds
	static unsigned int GetRealTime();

private:

	static void InitVirtualTimer();

	static float mVirtualTimerSpeed;
	static signed int mVirtualTimerStopCounter;
	static unsigned int mStartRealTime;
	static unsigned int mLastVirtualTime;
	static unsigned int mStaticTime;
};

#endif

